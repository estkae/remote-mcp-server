/**
 * Production Tools - Echte Implementierungen f√ºr Skill-Tools
 *
 * Dieses Modul enth√§lt die realen Implementierungen f√ºr:
 * - PowerPoint-Erstellung (pptxgenjs)
 * - Excel-Erstellung (exceljs)
 * - Weitere Production-ready Tools
 */

const PptxGenJS = require('pptxgenjs');
const ExcelJS = require('exceljs');
const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } = require('docx');
const pdfParse = require('pdf-parse');
const fs = require('fs').promises;
const path = require('path');

// Output-Verzeichnis f√ºr generierte Dateien
const OUTPUT_DIR = process.env.OUTPUT_DIR || path.join(__dirname, 'output');

// Stelle sicher, dass Output-Verzeichnis existiert
async function ensureOutputDir() {
  try {
    await fs.access(OUTPUT_DIR);
  } catch {
    await fs.mkdir(OUTPUT_DIR, { recursive: true });
    console.log(`üìÅ Created output directory: ${OUTPUT_DIR}`);
  }
}

/**
 * PowerPoint-Erstellung (Production)
 *
 * @param {Object} parameters - PowerPoint-Parameter
 * @param {string} parameters.title - Titel der Pr√§sentation
 * @param {Array} parameters.slides - Array von Folien
 * @param {string} parameters.filename - Dateiname (optional)
 * @returns {Promise<Object>} - Ergebnis mit Dateipfad
 */
async function createPowerPoint(parameters) {
  await ensureOutputDir();

  const { title, slides, filename } = parameters;

  // Validierung
  if (!title || !slides || !Array.isArray(slides)) {
    throw new Error('Invalid parameters: title and slides[] required');
  }

  // Erstelle neue Pr√§sentation
  const pptx = new PptxGenJS();

  // Pr√§sentations-Metadaten
  pptx.author = 'AALS Software AG - MCP Server';
  pptx.company = 'AALS Software AG';
  pptx.title = title;
  pptx.subject = 'Generated via MCP PowerPoint Skill';

  // Erstelle Titelfolie
  const titleSlide = pptx.addSlide();
  titleSlide.addText(title, {
    x: 0.5,
    y: 2.5,
    w: 9,
    h: 1.5,
    fontSize: 44,
    bold: true,
    color: '363636',
    align: 'center'
  });

  titleSlide.addText('Generated by AALS MCP Server', {
    x: 0.5,
    y: 4.5,
    w: 9,
    h: 0.5,
    fontSize: 14,
    color: '666666',
    align: 'center',
    italic: true
  });

  // Erstelle Content-Folien
  slides.forEach((slideData, index) => {
    const slide = pptx.addSlide();

    // Slide-Titel
    if (slideData.title) {
      slide.addText(slideData.title, {
        x: 0.5,
        y: 0.5,
        w: 9,
        h: 0.75,
        fontSize: 32,
        bold: true,
        color: '363636'
      });
    }

    // Slide-Content
    if (slideData.content && Array.isArray(slideData.content)) {
      const contentText = slideData.content.map(item => `‚Ä¢ ${item}`).join('\n');

      slide.addText(contentText, {
        x: 0.5,
        y: 1.5,
        w: 9,
        h: 4.5,
        fontSize: 18,
        color: '363636',
        bullet: false,
        valign: 'top'
      });
    }

    // Foliennummer
    slide.addText(`${index + 2} / ${slides.length + 1}`, {
      x: 9.0,
      y: 6.8,
      w: 0.5,
      h: 0.3,
      fontSize: 10,
      color: '999999',
      align: 'right'
    });
  });

  // Dateiname generieren
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const outputFilename = filename || `presentation_${timestamp}.pptx`;
  const outputPath = path.join(OUTPUT_DIR, outputFilename);

  // Speichere Pr√§sentation
  await pptx.writeFile({ fileName: outputPath });

  console.log(`‚úÖ PowerPoint created: ${outputPath}`);

  return {
    success: true,
    tool: 'create_powerpoint',
    filename: outputFilename,
    path: outputPath,
    slides_count: slides.length + 1, // +1 f√ºr Titelfolie
    file_size: (await fs.stat(outputPath)).size,
    message: `PowerPoint-Pr√§sentation "${title}" erfolgreich erstellt`,
    timestamp: new Date().toISOString()
  };
}

/**
 * Excel-Erstellung (Production)
 *
 * @param {Object} parameters - Excel-Parameter
 * @param {string} parameters.filename - Dateiname
 * @param {Array} parameters.sheets - Array von Sheets
 * @returns {Promise<Object>} - Ergebnis mit Dateipfad
 */
async function createExcel(parameters) {
  await ensureOutputDir();

  const { filename, sheets } = parameters;

  // Validierung
  if (!filename || !sheets || !Array.isArray(sheets)) {
    throw new Error('Invalid parameters: filename and sheets[] required');
  }

  // Erstelle neue Workbook
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'AALS Software AG - MCP Server';
  workbook.created = new Date();
  workbook.modified = new Date();

  // Erstelle Sheets
  sheets.forEach(sheetData => {
    const worksheet = workbook.addWorksheet(sheetData.name || 'Sheet1');

    // F√ºge Daten hinzu
    if (sheetData.data && Array.isArray(sheetData.data)) {
      sheetData.data.forEach((row, rowIndex) => {
        worksheet.addRow(row);

        // Header-Zeile formatieren
        if (rowIndex === 0) {
          const headerRow = worksheet.getRow(1);
          headerRow.font = { bold: true };
          headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFE0E0E0' }
          };
        }
      });

      // Auto-width f√ºr Spalten
      worksheet.columns.forEach(column => {
        let maxLength = 0;
        column.eachCell({ includeEmpty: true }, cell => {
          const length = cell.value ? cell.value.toString().length : 10;
          if (length > maxLength) {
            maxLength = length;
          }
        });
        column.width = Math.min(maxLength + 2, 50);
      });
    }
  });

  // Dateiname mit Timestamp
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const outputFilename = filename.endsWith('.xlsx') ? filename : `${filename}_${timestamp}.xlsx`;
  const outputPath = path.join(OUTPUT_DIR, outputFilename);

  // Speichere Workbook
  await workbook.xlsx.writeFile(outputPath);

  console.log(`‚úÖ Excel created: ${outputPath}`);

  return {
    success: true,
    tool: 'create_excel',
    filename: outputFilename,
    path: outputPath,
    sheets_count: sheets.length,
    file_size: (await fs.stat(outputPath)).size,
    message: `Excel-Datei "${outputFilename}" erfolgreich erstellt`,
    timestamp: new Date().toISOString()
  };
}

/**
 * Word-Dokument-Erstellung (Production)
 *
 * @param {Object} parameters - Word-Parameter
 * @param {string} parameters.title - Titel des Dokuments
 * @param {Array} parameters.sections - Array von Abschnitten
 * @param {string} parameters.filename - Dateiname (optional)
 * @returns {Promise<Object>} - Ergebnis mit Dateipfad
 */
async function createWord(parameters) {
  await ensureOutputDir();

  const { title, sections, filename } = parameters;

  // Validierung
  if (!title || !sections || !Array.isArray(sections)) {
    throw new Error('Invalid parameters: title and sections[] required');
  }

  // Erstelle Paragraphen f√ºr das Dokument
  const documentChildren = [];

  // Titel
  documentChildren.push(
    new Paragraph({
      text: title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    })
  );

  // Abschnitte
  sections.forEach(section => {
    // √úberschrift des Abschnitts
    if (section.heading) {
      const headingLevel = {
        'heading1': HeadingLevel.HEADING_1,
        'heading2': HeadingLevel.HEADING_2,
        'heading3': HeadingLevel.HEADING_3,
        'normal': null
      }[section.style || 'normal'];

      if (headingLevel) {
        documentChildren.push(
          new Paragraph({
            text: section.heading,
            heading: headingLevel,
            spacing: { before: 240, after: 120 }
          })
        );
      } else {
        documentChildren.push(
          new Paragraph({
            text: section.heading,
            spacing: { before: 240, after: 120 },
            bold: true
          })
        );
      }
    }

    // Content des Abschnitts
    if (section.content) {
      const contentParagraphs = section.content.split('\n');
      contentParagraphs.forEach(para => {
        documentChildren.push(
          new Paragraph({
            text: para,
            spacing: { after: 120 }
          })
        );
      });
    }
  });

  // Footer
  documentChildren.push(
    new Paragraph({
      text: '',
      spacing: { before: 400 }
    }),
    new Paragraph({
      text: 'Erstellt mit AALS MCP Server',
      alignment: AlignmentType.CENTER,
      italics: true
    })
  );

  // Erstelle Word-Dokument
  const doc = new Document({
    creator: 'AALS Software AG - MCP Server',
    title: title,
    description: 'Generated via MCP Word Skill',
    sections: [{
      properties: {},
      children: documentChildren
    }]
  });

  // Dateiname generieren
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
  const outputFilename = filename || `document_${timestamp}.docx`;
  const outputPath = path.join(OUTPUT_DIR, outputFilename);

  // Speichere Dokument
  const buffer = await Packer.toBuffer(doc);
  await fs.writeFile(outputPath, buffer);

  console.log(`‚úÖ Word document created: ${outputPath}`);

  return {
    success: true,
    tool: 'create_word',
    filename: outputFilename,
    path: outputPath,
    sections_count: sections.length,
    file_size: buffer.length,
    message: `Word-Dokument "${title}" erfolgreich erstellt`,
    timestamp: new Date().toISOString()
  };
}

/**
 * PDF-Lesen (Production)
 *
 * @param {Object} parameters - PDF-Parameter
 * @param {string} parameters.filepath - Pfad zur PDF-Datei
 * @returns {Promise<Object>} - Ergebnis mit PDF-Inhalt
 */
async function readPDF(parameters) {
  const { filepath } = parameters;

  // Validierung
  if (!filepath) {
    throw new Error('Invalid parameters: filepath required');
  }

  try {
    // Pr√ºfe ob Datei existiert
    const dataBuffer = await fs.readFile(filepath);

    // Parse PDF
    const data = await pdfParse(dataBuffer);

    console.log(`‚úÖ PDF parsed: ${filepath} (${data.numpages} pages)`);

    return {
      success: true,
      tool: 'read_pdf',
      filepath: filepath,
      num_pages: data.numpages,
      text_length: data.text.length,
      text: data.text,
      info: data.info,
      metadata: data.metadata,
      message: `PDF erfolgreich gelesen: ${data.numpages} Seiten`,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error(`‚ùå PDF read failed:`, error.message);
    throw new Error(`PDF-Lesen fehlgeschlagen: ${error.message}`);
  }
}

/**
 * Brand Guidelines anwenden (Production Placeholder)
 */
async function applyBrandGuidelines(parameters) {
  const { content, brand } = parameters;

  // TODO: Implementiere echte Brand-Guidelines-Logik
  return {
    success: true,
    tool: 'apply_brand_guidelines',
    brand: brand || 'default',
    content_length: content.length,
    message: 'Brand Guidelines-Anwendung noch nicht implementiert',
    note: 'Production-Implementierung folgt',
    timestamp: new Date().toISOString()
  };
}

/**
 * Code Review (Production Placeholder)
 */
async function reviewCode(parameters) {
  const { code, language } = parameters;

  // TODO: Implementiere echtes Code-Review mit Linting-Tools
  return {
    success: true,
    tool: 'review_code',
    language: language,
    code_length: code.length,
    message: 'Code-Review noch nicht implementiert',
    note: 'Production-Implementierung folgt (k√∂nnte ESLint/Pylint integrieren)',
    timestamp: new Date().toISOString()
  };
}

/**
 * Blog Post schreiben (Production Placeholder)
 */
async function writeBlogPost(parameters) {
  const { topic, keywords } = parameters;

  // TODO: Implementiere echte Blog-Post-Generierung
  return {
    success: true,
    tool: 'write_blog_post',
    topic: topic,
    keywords: keywords || [],
    message: 'Blog-Post-Generierung noch nicht implementiert',
    note: 'Production-Implementierung folgt',
    timestamp: new Date().toISOString()
  };
}

/**
 * Hauptfunktion: Route Tool-Execution zu richtiger Production-Funktion
 *
 * @param {string} toolName - Name des Tools
 * @param {Object} parameters - Tool-Parameter
 * @returns {Promise<Object>} - Ergebnis der Tool-Ausf√ºhrung
 */
async function executeProductionTool(toolName, parameters) {
  console.log(`üöÄ [PRODUCTION MODE] Executing: ${toolName}`);

  try {
    let result;

    switch (toolName) {
      case 'create_powerpoint':
      case 'create_powerpoint_presentation':
        result = await createPowerPoint(parameters);
        break;

      case 'create_excel':
        result = await createExcel(parameters);
        break;

      case 'create_word':
        result = await createWord(parameters);
        break;

      case 'read_pdf':
        result = await readPDF(parameters);
        break;

      case 'apply_brand_guidelines':
        result = await applyBrandGuidelines(parameters);
        break;

      case 'review_code':
        result = await reviewCode(parameters);
        break;

      case 'write_blog_post':
        result = await writeBlogPost(parameters);
        break;

      default:
        throw new Error(`Unknown production tool: ${toolName}`);
    }

    result.mode = 'PRODUCTION';
    return result;

  } catch (error) {
    console.error(`‚ùå Production tool error (${toolName}):`, error);
    throw error;
  }
}

module.exports = {
  executeProductionTool,
  createPowerPoint,
  createExcel,
  createWord,
  readPDF,
  applyBrandGuidelines,
  reviewCode,
  writeBlogPost,
  ensureOutputDir
};